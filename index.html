<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Croto Noise</title>
</head>
<body>
<style>
  *{
    margin: 0;
  }
</style>
<script type="module">
    import * as THREE from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r132/three.module.js';
    import { OrbitControls } from 'https://threejsfundamentals.org/threejs/resources/threejs/r132/examples/jsm/controls/OrbitControls.js';

  document.addEventListener("DOMContentLoaded", function () {
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();

    const bufferSize1 = 2 * audioContext.sampleRate;
    const noiseBuffer1 = audioContext.createBuffer(1, bufferSize1, audioContext.sampleRate);
    const output1 = noiseBuffer1.getChannelData(0);

    for (let i = 0; i < bufferSize1; i++) {
      output1[i] = Math.random() * 2 - 1;
    }

    const noiseSource1 = audioContext.createBufferSource();
    noiseSource1.buffer = noiseBuffer1;
    noiseSource1.loop = true;

    const gainNode1 = audioContext.createGain();
    noiseSource1.connect(gainNode1);
    gainNode1.connect(audioContext.destination);

    let isMouseDown1 = false;
    let isFirstInteraction1 = true;

    function startNoiseSource1() {
      if (isFirstInteraction1) {
        noiseSource1.start();
        isFirstInteraction1 = false;
      }
    }

    function changeVolumeAndFrequencyRandomly1() {
      if (isMouseDown1) {
        const randomVolume = Math.random() * 0.9 + 0.1;
        const randomFrequency = Math.random() * 5000 + 500;

        gainNode1.gain.setValueAtTime(randomVolume, audioContext.currentTime);
        noiseSource1.playbackRate.setValueAtTime(randomFrequency / audioContext.sampleRate, audioContext.currentTime);
      }

      const nextInterval1 = Math.random() * 60;
      setTimeout(changeVolumeAndFrequencyRandomly1, nextInterval1);
    }

    function handleMouseDown1(event) {
      isMouseDown1 = true;
      startNoiseSource1();
      handleMouseClick1(event);
    }

    function handleMouseUp1() {
      isMouseDown1 = false;
      gainNode1.gain.setValueAtTime(0.1, audioContext.currentTime);
      noiseSource1.playbackRate.setValueAtTime(1000 / audioContext.sampleRate, audioContext.currentTime);
    }

    function handleMouseClick1(event) {
      const clickX = event.clientX / window.innerWidth;
      const minFrequency = 100;
      const maxFrequency = 5000;
      const targetFrequency = minFrequency + clickX * (maxFrequency - minFrequency);

      const clickY = event.clientY / window.innerHeight;
      const minVolumeDuration = 0;
      const maxVolumeDuration = 0.8;
      const targetVolumeDuration = minVolumeDuration + clickY * (maxVolumeDuration - minVolumeDuration);

      gainNode1.gain.linearRampToValueAtTime(0.1, audioContext.currentTime);
      gainNode1.gain.linearRampToValueAtTime(1.0, audioContext.currentTime + targetVolumeDuration);

      noiseSource1.playbackRate.setValueAtTime(targetFrequency / audioContext.sampleRate, audioContext.currentTime);
    }

    function handleMouseMove1(event) {
      if (isMouseDown1) {
        const moveX = event.clientX / window.innerWidth;
        const minFrequency = 0;
        const maxFrequency = 10000;
        const targetFrequency = minFrequency + moveX * (maxFrequency - minFrequency);

        noiseSource1.playbackRate.setValueAtTime(targetFrequency / audioContext.sampleRate, audioContext.currentTime + 1);
      }
    }

    document.addEventListener('mousedown', handleMouseDown1);
    document.addEventListener('mouseup', handleMouseUp1);
    document.addEventListener('mousemove', handleMouseMove1);

    changeVolumeAndFrequencyRandomly1();

    const bufferSize2 = 2 * audioContext.sampleRate;
    const noiseBuffer2 = audioContext.createBuffer(1, bufferSize2, audioContext.sampleRate);
    const output2 = noiseBuffer2.getChannelData(0);

    for (let i = 0; i < bufferSize2; i++) {
      output2[i] = Math.random() * 2 - 1;
    }

    const noiseSource2 = audioContext.createBufferSource();
    noiseSource2.buffer = noiseBuffer2;
    noiseSource2.loop = true;

    const gainNode2 = audioContext.createGain();
    noiseSource2.connect(gainNode2);
    gainNode2.connect(audioContext.destination);

    let isMouseDown2 = false;
    let isFirstInteraction2 = true;

    function startNoiseSource2() {
      if (isFirstInteraction2) {
        noiseSource2.start();
        isFirstInteraction2 = false;
      }
    }

    function changeVolumeAndFrequencyRandomly2() {
      if (isMouseDown2) {
        const randomVolume = Math.random() * 0.9 + 0.1;
        const randomFrequency = Math.random() * 5000 + 500;

        gainNode2.gain.setValueAtTime(randomVolume, audioContext.currentTime);
        noiseSource2.playbackRate.setValueAtTime(randomFrequency / audioContext.sampleRate, audioContext.currentTime);
      }

      const nextInterval2 = Math.random() * 100;
      setTimeout(changeVolumeAndFrequencyRandomly2, nextInterval2);
    }

    function handleMouseDown2(event) {
      isMouseDown2 = true;
      startNoiseSource2();
      handleMouseClick2(event);
    }

    function handleMouseUp2() {
      isMouseDown2 = false;
      gainNode2.gain.setValueAtTime(0.1, audioContext.currentTime);
      noiseSource2.playbackRate.setValueAtTime(1000 / audioContext.sampleRate, audioContext.currentTime);
    }

    function handleMouseClick2(event) {
      const clickX = event.clientX / window.innerWidth;
      const minFrequency = 100;
      const maxFrequency = 5000;
      const targetFrequency = minFrequency + clickX * (maxFrequency - minFrequency);

      const clickY = event.clientY / window.innerHeight;
      const minVolumeDuration = 0;
      const maxVolumeDuration = 0.8;
      const targetVolumeDuration = minVolumeDuration + clickY * (maxVolumeDuration - minVolumeDuration);

      gainNode2.gain.linearRampToValueAtTime(0.1, audioContext.currentTime);
      gainNode2.gain.linearRampToValueAtTime(1.0, audioContext.currentTime + targetVolumeDuration);

      noiseSource2.playbackRate.setValueAtTime(targetFrequency / audioContext.sampleRate, audioContext.currentTime);
    }

    function handleMouseMove2(event) {
      if (isMouseDown2) {
        const moveX = event.clientX / window.innerWidth;
        const minFrequency = 0;
        const maxFrequency = 10000;
        const targetFrequency = minFrequency + moveX * (maxFrequency - minFrequency);

        noiseSource2.playbackRate.setValueAtTime(targetFrequency / audioContext.sampleRate, audioContext.currentTime + 1);
      }
    }

    document.addEventListener('mousedown', handleMouseDown2);
    document.addEventListener('mouseup', handleMouseUp2);
    document.addEventListener('mousemove', handleMouseMove2);

    changeVolumeAndFrequencyRandomly2();

    const analyser1 = audioContext.createAnalyser();
    analyser1.fftSize = 256;
    gainNode1.connect(analyser1);

    const analyser2 = audioContext.createAnalyser();
    analyser2.fftSize = 256;
    gainNode2.connect(analyser2);

    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    
    camera.position.z = 5;
    
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);

    const geometry = new THREE.PlaneGeometry(5, 5, 60, 60);

    const material = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true });

    const plane = new THREE.Mesh(geometry, material);
    scene.add(plane);

    function animate() {
      requestAnimationFrame(animate);

      const data1 = new Uint8Array(analyser1.frequencyBinCount);
      analyser1.getByteFrequencyData(data1);

      const data2 = new Uint8Array(analyser2.frequencyBinCount);
      analyser2.getByteFrequencyData(data2);

      const positions = geometry.attributes.position.array;
      for (let i = 2; i < positions.length; i += 7) {
        const scaleFactor = 1 + (data1[i % data1.length] + data2[i % data2.length]) / 510 * 5;
        positions[i] = scaleFactor * 0.5;
      }

      geometry.attributes.position.needsUpdate = true;

      controls.update();

      renderer.render(scene, camera);
    }

    animate();
  });
</script>
</body>
</html>
